// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name HyperTrack
import CoreLocation.CLLocation
import CoreMotion.CMMotionActivity
import CoreMotion.CMPedometer
import Compression
import CoreLocation
import CoreMotion
import CoreTelephony
import Foundation
@_exported import HyperTrack
import SQLite3
import Swift
import SystemConfiguration
import UIKit
import UIKit/*.UIBackgroundFetchResult*/
import os.log
import os
import zlib
extension FloatingPoint {
  @inlinable internal func isAlmostEqual(to other: Self, tolerance: Self = Self.ulpOfOne.squareRoot()) -> Swift.Bool {
    // tolerances outside of [.ulpOfOne,1) yield well-defined but useless results,
    // so this is enforced by an assert rathern than a precondition.
    assert(
      tolerance >= .ulpOfOne && tolerance < 1,
      "tolerance should be in [.ulpOfOne, 1)."
    )
    // The simple computation below does not necessarily give sensible
    // results if one of self or other is infinite; we need to rescale
    // the computation in that case.
    guard isFinite, other.isFinite else {
      return rescaledAlmostEqual(to: other, tolerance: tolerance)
    }
    // This should eventually be rewritten to use a scaling facility to be
    // defined on FloatingPoint suitable for hypot and scaled sums, but the
    // following is good enough to be useful for now.
    let scale = max(abs(self), abs(other), .leastNormalMagnitude)
    return abs(self - other) < scale * tolerance
  }
  @inlinable internal func isAlmostZero(absoluteTolerance tolerance: Self = Self.ulpOfOne.squareRoot()) -> Swift.Bool {
    assert(tolerance > 0)
    return abs(self) < tolerance
  }
  @usableFromInline
  internal func rescaledAlmostEqual(to other: Self, tolerance: Self) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objcMembers final public class HTMetadata : ObjectiveC.NSObject {
  @objc override convenience dynamic public init()
  @objc convenience public init?(dictionary: [Swift.String : Any])
  @objc convenience public init?(jsonString: Swift.String)
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @objcMembers final public class HTSDK : ObjectiveC.NSObject {
  @objc public static let startedTrackingNotification: Foundation.NSNotification.Name
  @objc public static let stoppedTrackingNotification: Foundation.NSNotification.Name
  @objc public static let didEncounterRestorableErrorNotification: Foundation.NSNotification.Name
  @objc public static let didEncounterUnrestorableErrorNotification: Foundation.NSNotification.Name
  @objc final public let deviceID: Swift.String
  @objc convenience public init?(publishableKey: Swift.String)
  @objc convenience public init?(publishableKey: Swift.String, automaticallyRequestPermissions: Swift.Bool = true)
  @objc public static func makeSDK(publishableKey: Swift.String) -> HTResult
  @objc public static func makeSDK(publishableKey: Swift.String, automaticallyRequestPermissions: Swift.Bool = true) -> HTResult
  @objc final public var isRunning: Swift.Bool {
    @objc get
  }
  @objc final public func setDeviceName(_ deviceName: Swift.String)
  @objc final public func setDeviceMetadata(_ metadata: HTMetadata)
  @objc final public func start()
  @objc final public func stop()
  @objc final public func syncDeviceSettings()
  @objc final public func addGeotag(_ tag: HTMetadata)
  @objc public static func registerForRemoteNotifications()
  @objc public static func didRegisterForRemoteNotificationsWithDeviceToken(_ deviceToken: Foundation.Data)
  @objc public static func didFailToRegisterForRemoteNotificationsWithError(_ error: Swift.Error)
  @objc public static func didReceiveRemoteNotification(_ userInfo: [Swift.AnyHashable : Any], fetchCompletionHandler completionHandler: @escaping (UIKit.UIBackgroundFetchResult) -> Swift.Void)
  @objc @available(*, deprecated, message: "Use addGeoTag: instead.")
  final public func addTripMarker(_ marker: HTMetadata)
  @objc deinit
  @objc override dynamic public init()
}
@objc extension NSError {
  @objc public static let HTFatalErrorDomain: Swift.String
  @objc public static let HTRestorableErrorDomain: Swift.String
  @objc public static let HTUnrestorableErrorDomain: Swift.String
}
@objc public enum HTFatalError : Swift.Int {
  case developmentPublishableKeyIsEmpty = -4110
  case developmentMissingLocationUpdatesBackgroundModeCapability = -4111
  case developmentRunningOnSimulatorUnsupported = -4112
  case productionLocationServicesUnavalible = -4121
  case productionMotionActivityServicesUnavalible = -4122
  @available(*, deprecated, message: "Motion permissions denied before initialization no longer produces an error.")
  case productionMotionActivityPermissionsDenied = -4123
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum HTRestorableError : Swift.Int {
  case locationPermissionsDenied = -4200
  case locationServicesDisabled = -4201
  case motionActivityServicesDisabled = -4202
  @available(*, deprecated, message: "That error is no longer available.")
  case networkConnectionUnavailable = -4203
  case trialEnded = -4204
  case paymentDefault = -4205
  case locationPermissionsNotDetermined = -4206
  case locationPermissionsRestricted = -4207
  case motionActivityPermissionsNotDetermined = -4208
  case locationPermissionsInsufficientForBackground = -4209
  case locationPermissionsCantBeAskedInBackground = -4210
  case motionActivityPermissionsCantBeAskedInBackground = -4211
  case motionActivityPermissionsRestricted = -4212
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum HTUnrestorableError : Swift.Int {
  case invalidPublishableKey = -4300
  case motionActivityPermissionsDenied = -4301
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc @_hasMissingDesignatedInitializers @objcMembers final public class HTResult : ObjectiveC.NSObject {
  @objc final public let hyperTrack: HTSDK?
  @objc final public let error: Foundation.NSError?
  @objc deinit
  @objc override dynamic public init()
}
@objc extension NSNotification {
  @objc dynamic public func hyperTrackTrackingError() -> Foundation.NSError?
  @objc dynamic public func hyperTrackRestorableError() -> Foundation.NSError?
  @objc dynamic public func hyperTrackUnrestorableError() -> Foundation.NSError?
}
final public class HyperTrack {
  public static let startedTrackingNotification: Foundation.Notification.Name
  public static let stoppedTrackingNotification: Foundation.Notification.Name
  public static let didEncounterRestorableErrorNotification: Foundation.Notification.Name
  public static let didEncounterUnrestorableErrorNotification: Foundation.Notification.Name
  final public let deviceID: Swift.String
  public init(publishableKey: HyperTrack.PublishableKey, automaticallyRequestPermissions: Swift.Bool = true) throws
  public static func makeSDK(publishableKey: HyperTrack.PublishableKey, automaticallyRequestPermissions: Swift.Bool = true) -> Swift.Result<HyperTrack, HyperTrack.FatalError>
  final public var isRunning: Swift.Bool {
    get
  }
  final public func setDeviceName(_ deviceName: Swift.String)
  final public func setDeviceMetadata(_ metadata: HyperTrack.Metadata)
  final public func start()
  final public func stop()
  final public func syncDeviceSettings()
  final public func addGeotag(_ tag: HyperTrack.Metadata)
  public static func registerForRemoteNotifications()
  public static func didRegisterForRemoteNotificationsWithDeviceToken(_ deviceToken: Foundation.Data)
  public static func didFailToRegisterForRemoteNotificationsWithError(_ error: Swift.Error)
  public static func didReceiveRemoteNotification(_ userInfo: [Swift.AnyHashable : Any], fetchCompletionHandler completionHandler: @escaping (UIKit.UIBackgroundFetchResult) -> Swift.Void)
  public struct PublishableKey {
    public init?(_ publishableKey: Swift.String)
    public init(_ firstCharacter: Swift.Character, _ restOfTheKey: Swift.String)
  }
  public struct Metadata : Swift.RawRepresentable {
    public typealias RawValue = [Swift.String : Any]
    public let rawValue: HyperTrack.Metadata.RawValue
    public init()
    public init?(rawValue: HyperTrack.Metadata.RawValue)
    public init?(dictionary: [Swift.String : Any])
    public init?(jsonString: Swift.String)
  }
  @frozen public enum FatalError : Swift.Error {
    case developmentError(HyperTrack.DevelopmentError)
    case productionError(HyperTrack.ProductionError)
    public var developmentError: HyperTrack.DevelopmentError? {
      get
    }
    public var productionError: HyperTrack.ProductionError? {
      get
    }
  }
  public enum DevelopmentError : Swift.Error {
    case missingLocationUpdatesBackgroundModeCapability
    case runningOnSimulatorUnsupported
    public static func == (a: HyperTrack.DevelopmentError, b: HyperTrack.DevelopmentError) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum ProductionError : Swift.Error {
    case locationServicesUnavalible
    case motionActivityServicesUnavalible
    @available(*, deprecated, message: "Motion permissions denied before initialization no longer produces an error.")
    case motionActivityPermissionsDenied
    public static func == (a: HyperTrack.ProductionError, b: HyperTrack.ProductionError) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum RestorableError : Swift.Error {
    case locationPermissionsNotDetermined
    case motionActivityPermissionsNotDetermined
    case locationPermissionsCantBeAskedInBackground
    case motionActivityPermissionsCantBeAskedInBackground
    case locationPermissionsRestricted
    case motionActivityPermissionsRestricted
    case locationPermissionsDenied
    case locationPermissionsInsufficientForBackground
    case locationServicesDisabled
    case motionActivityServicesDisabled
    @available(*, deprecated, message: "That error is no longer available.")
    case networkConnectionUnavailable
    case trialEnded
    case paymentDefault
    public static func == (a: HyperTrack.RestorableError, b: HyperTrack.RestorableError) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum UnrestorableError : Swift.Error {
    case invalidPublishableKey
    case motionActivityPermissionsDenied
    public static func == (a: HyperTrack.UnrestorableError, b: HyperTrack.UnrestorableError) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  @frozen public enum TrackingError {
    case restorableError(HyperTrack.RestorableError)
    case unrestorableError(HyperTrack.UnrestorableError)
    public var restorableError: HyperTrack.RestorableError? {
      get
    }
    public var unrestorableError: HyperTrack.UnrestorableError? {
      get
    }
  }
  @available(*, deprecated, message: "Use addGeotag: instead.")
  final public func addTripMarker(_ marker: HyperTrack.Metadata)
  @objc deinit
}
extension Notification {
  public func hyperTrackTrackingError() -> HyperTrack.TrackingError?
  public func hyperTrackRestorableError() -> HyperTrack.RestorableError?
  public func hyperTrackUnrestorableError() -> HyperTrack.UnrestorableError?
}
@available(iOS 10.0, *)
extension OSLog {
  @inlinable internal func log(_ value: Swift.String, file: Swift.String, function: Swift.String, line: Swift.Int) {
    _log(
      value: value,
      file: file,
      function: function,
      line: line,
      type: .default
    )
  }
  @inlinable internal func info(_ value: Swift.String, file: Swift.String, function: Swift.String, line: Swift.Int) {
      // @workaround for simulator bug in Xcode 10.2 and earlier:
      // https://forums.developer.apple.com/thread/82736#348090
      let type = OSLogType.default
    _log(value: value, file: file, function: function, line: line, type: type)
  }
  @inlinable internal func trace(file: Swift.String, function: Swift.String, line: Swift.Int) {
      // @workaround for simulator bug in Xcode 10.2 and earlier:
      // https://forums.developer.apple.com/thread/82736#348090
      let type = OSLogType.default
    _log(
      value: "<OSLog.trace>",
      file: file,
      function: function,
      line: line,
      type: type
    )
  }
  @inlinable internal func debug(_ value: Swift.String, file: Swift.String, function: Swift.String, line: Swift.Int) {
      // @workaround for simulator bug in Xcode 10.2 and earlier:
      // https://forums.developer.apple.com/thread/82736#348090
      let type = OSLogType.default
    _log(value: value, file: file, function: function, line: line, type: type)
  }
  @inlinable internal func error(_ value: Swift.String, file: Swift.String, function: Swift.String, line: Swift.Int) {
    _log(value: value, file: file, function: function, line: line, type: .error)
  }
  @inlinable internal func fault(_ value: Swift.String, file: Swift.String, function: Swift.String, line: Swift.Int) {
    _log(value: value, file: file, function: function, line: line, type: .fault)
  }
  @usableFromInline
  internal func _log(value: Swift.String, file: Swift.String, function: Swift.String, line: Swift.Int, type: os.OSLogType)
}
extension HTFatalError : Swift.Equatable {}
extension HTFatalError : Swift.Hashable {}
extension HTFatalError : Swift.RawRepresentable {}
extension HTRestorableError : Swift.Equatable {}
extension HTRestorableError : Swift.Hashable {}
extension HTRestorableError : Swift.RawRepresentable {}
extension HTUnrestorableError : Swift.Equatable {}
extension HTUnrestorableError : Swift.Hashable {}
extension HTUnrestorableError : Swift.RawRepresentable {}
extension HyperTrack.DevelopmentError : Swift.Equatable {}
extension HyperTrack.DevelopmentError : Swift.Hashable {}
extension HyperTrack.ProductionError : Swift.Equatable {}
extension HyperTrack.ProductionError : Swift.Hashable {}
extension HyperTrack.RestorableError : Swift.Equatable {}
extension HyperTrack.RestorableError : Swift.Hashable {}
extension HyperTrack.UnrestorableError : Swift.Equatable {}
extension HyperTrack.UnrestorableError : Swift.Hashable {}
